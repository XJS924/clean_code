#### 第7章 错误处理

> 应该弄清楚错误处理与整洁代码的关系。错误处理很重要，但如果他搞乱了代码逻辑，就是错误的做法。

##### 7.1 使用异常而非返回码

##### 7.3 使用不可控异常

> 可控异常的代价就是违反开放、闭合原则。如果在方法中抛出可控异常，而catch语句在三个层级之上，你就得在catch语句和抛出异常处之间的每个方法签名中声明该异常。

> 如果异常是可控的，则函数签名就要添加throw子句。这以为着每个调用该函数的函数都要修改，捕获新异常，或在其签名中添加合适的throw子句。以此类推，最终得到的就是一个从软件最低端贯穿到最高端的修改链。封装被到了。

> 可控异常以这种方式破坏封装简直就是一种耻辱。

##### 7.4 给出异常发生的环境说明

> 你抛出的每个异常都应当提供足够的环境说明，以判断错误的来源和处所。在java中，你可以从任何异常里得到推展踪迹（stack trace）；然而堆栈踪迹却无法告诉你该失败操作的初衷。

> 应创建信息充分的错误信息，并和异常一起传递出去。在消息中，包括失败的操作和失败的类型。

##### 7.5 依调用者需要定义异常类

> 当我们在应用程序中定义异常类时，最重要的考虑应该是他们如何被捕获。

> 打包的好处还在于你不必绑定在某个特定厂商的API设计上。

##### 7.6 定义常规流程

> 创建一个类或配置一个对象来处理特例。你来处理特例，客户代码就不用应付异常行为了，异常行为被封装到特例对象中。

##### 7.7 别返回null值

> 返回null值基本是在给自己添加工作量，也是在给调用者添乱。只要有一处没有检查null值，应用程序就会失控。

```java
List<Employee> employees = getEmployees();
if(employees !=null){
	for(Employee e:employees){
	totalPay +=e.getPay();
	}
}
```

如果修改getEmployee,返回空列表，就能使代码整洁起来：

```java
List<Employee> employees = getEmployees();
for(Employee e:employees){
	totalPay +=e.getPay();
}
public List<Employee> getEmployees(){
    if (...there are no employees...){
        return Collections.emptyList();
    }
}
```

> 这样编码就能尽量避免NullPointerException的出现，代码就更整洁了。

##### 7.8 别传递null值

> 在方法中返回null值是槽糕的做法，但将null值传递给其他地方就更槽糕了。

> 最恰当的做法就是禁止传入null值。

##### 7.9 小结

> 整洁代码是刻度的，但也要强固。可读与强固并不冲突。如果将错误处理隔离看待，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它。也能极大提升代码的可维护性。







> 遇到错误时，最好抛出一个异常。调整代码很整洁，其逻辑不会被错误处理搞乱。

> 业务处理与错误处理被隔离开。

##### 7.2 先写Try-Catch-Finally语句

> 异常的妙处之一是，他们在程序中定义了一个范围。执行Try-Catch-Finally语句中try部分的代码时，你是在表明可随时取消执行，并在catch语句中接续。

> 在某种意义上，try代码块就像是事务，catch代码块将程序维持在一种持续状态。无论try代码块发生了什么均如此。所以，用户在编写可能抛出异常的代码块时，最好先写出try-catch-finally语句。
>
> 

