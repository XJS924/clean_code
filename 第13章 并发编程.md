#### 第13章 并发编程

>  **对象是过程的抽象，线程是调度的抽象。**

> 编写整洁的并发程序很难——非常难。编写在单线程中执行的代码简单得多。编写表面上看来不错，深入进去却支离破碎的多线程代码也简单。系统一旦遭受压力，这种代码就扛不住了。

##### 13.1 为什么要并发

> 并发是一种解耦策略。他帮助我们把做什么（目的）和何时（时机）做分解开。在单线程中，目的和时机紧密耦合，很多时候只要查看堆栈追踪即可断定应用程序状态。

> 解耦目的与时机能明显改进应用程序的吞吐量和结构。

> 编写并发软件的中肯说法：
>
> - 并发会在性能和编写额外代码上增加一些开销；
> - 正确的并发是复杂的，即便对于简单的问题也是如此。
> - 并发缺陷并非总能重现，所以常备看做偶发事件而忽略，未被当做真的缺陷看待。
> - 并发常常需要对设计策略的根本性修改。

##### 13.2 挑战

> Java并发有很多路径可行，有些路径会产生错误的结果。有多少路径呢？要真正回答这个问题，需要理解Just-In-time编译器如何对待生成的字节码，还要理解Java内存模型认为什么东西具有原子性。
>
> 就生成的字节码而言，对于在getNextId方法中执行的那两个线程，有12870中不同的可能执行路径。如果lastIdUsed的类型从int变为long，则可能路径的数量将增至2704156种。当然，多数路径都得到正确结果。问题是其中一些不能得到正确的结果。

##### 13.3 并发防御原则

###### 13.3.1 单一权责原则（SRP）

> 单一职责原则（SRP)认为，方法、类、组件应当只有一个修改的理由。并发设计自身足够复杂到成为修改的理由。所以也该从其他代码中分离出来。不幸的是，并发实现细节常常直接嵌入到其他生产代码中。下面是要考虑的一些问题：
>
> - 并发相关代码有自己的开发、修改和调优生命周期。
> - 开发相关代码有自己要对付的挑战，和非并发相关代码不同，而且往往更为困难。
> - 即便没有周边应用程序增加的负担，写的不好的并发代码可能的出错方式数量已经足具挑战性；
>
> **建议：分离并发相关代码与其他代码。**

###### 13.3.2 推论：限制数据作用域

> 如我们所见，两个线程修改共享对象的同一字段时，可能互相干扰，导致未逾期的行为。解决方案之一是采用synchronized关键字在代码中保护一块使用共享对象的临界区（critical session)。限制临界区的数量很重要。更新共享数据的地方越多，就越可能：
>
> - 你会忘记保护一个或多个临界区--破坏了修改共享数据的代码；
> - 得花力气保证一切都收到有效保护（破坏了DRY原则）；
> - 很难找到错误源，也很难判断错误源。
>
> **建议：谨记数据封装；严格限制对可能被共享数据的访问。**

###### 13.3.3 推论：使用数据复本

> 避免共享数据的好方法之一就是一开始就避免共享数据。

###### 13.3.4 推论：线程应尽可能地独立

**建议：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集。**

##### 13.4 了解Java库









